# Chapter 05 목과 테스트 취약성

## 5.1.1 테스트 대역 유형

- 더미, 스텁, 스파이, 목, 페이크라는 다섯 가지가 존재하나, 실제로는 목과 스텁의 두 가지 유형으로 나눌 수 있음

  - 목: 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 됨
    - 목, 스파이 -> 목에 해당
    - SUT가 **상태를 변경하기 위한 의존성을 호출**하는 것에 해당
    - SMTP 서버로 이메일 발송 -> 목
      - SUT와 관련 의존성 간의 상호 작용을 모방하고 검사함
  - 스텁: 내부로 들어오는 상호 작용을 모방하는 데 도움이 됨
    - 스텁, 더미, 페이크 -> 스텁에 해당
    - SUT가 **입력 데이터를 얻기 위한 의존성을 호출**하는 것에 해당
    - DB에서 데이터 검색 -> 스텁
      - 스텁은 모방만 함

- 스파이: 수동으로 작성함
- 목: 목 프레임워크의 도움을 받아 생성됨
- 더미: 단순하고 하드코딩된 값 (ex. null, 가짜 문자열)
- 스텁: 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성
- 페이크: 대다수의 목적에 부합하는 스텁과 같음
  - 스텁과 페이크의 차이점은 **생성**에 있음
  - 보통 아직 존재하지 않는 의존성을 대체하고자 구현함

## 스텁으로 상호 작용을 검증하지 말라

```c#

[Fact]
public void Creating_a_report()
{
  var stub = new Mock<IDatabase>();
  stub.Setup(x => x.GetNumberOfUsers())
    .Returns(10);
  var sut = new Controller(stub.Object);

  Report report = sut.CreateReport();

  Assert.Equal(10, report.NumberOfUsers)

  // 과잉 명세
  stub.Vertify(
    x => x.GetNumberOfUsers(),
    Times.once
  );
}
```

SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아닌, 최종 결과를 산출하기 위한 수단일 뿐이므로 상호 작용을 검증하는 것은 안티패턴이다.

Mock에서 이메일을 전송하는 행위는 외부로 나가는 상호 작용이고 목적은 사이드 이펙트를 일으키는 것이다.

하지만 stub에서 NumberOfUsers 내부에 존재하는 메서드인 GetNumberOfUsers가 호출되는지 확인하는 것은 내부 구현 세부 사항을 검증하는 것이고,<br/>
이는 과잉 명세로 테스트 취약성으로 이어질 수 있다.

## 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?

명령 조회 분리(CQS)원칙과 관련이 있음

- 명령을 대체하는 것은 목, 조회를 대체하는 것은 스텁

CQS

- 모든 메서드는 명령이거나 조회여야 하며, 이 둘을 혼용해서는 안 된다.
- 명령: 사이드 이펙트를 일으키고 어떤 값도 반환하지 않음
- 조회: 사이드 이펙트가 없고 값을 반환함
  - 질문을 할 때, 답이 달라져선 안 됨(멱등성을 보장해야 함)
- 하지만 특수한 경우(pop의 경우) 반환할 수 있지만, 되도록이면 CQS 원칙을 따르는 것이 좋음

## 식별할 수 있는 동작과 구현 세부 사항

거짓 양성(리팩터링 내성에 실패하는) 주요 이유는 코드의 구현 세부 사항과 결합돼 있기 때문임

- 이를 해결하기 위해서는 강결합을 피해야 하고, 이 방법은 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부 사항과 테스트를 떨어뜨려야 함
- 즉, 테스트가 어떻게가 아닌 무엇에 중점을 두어야 함

## 식별할 수 있는 동작은 공개 API와 다르다.

모든 제품 코드는 2차원으로 분류할 수 있음

- 공개 API vs 비공개 API
  - 클래스의 어떤 멤버라도 private 키워드로 표시할 수 있으며, 해당 멤버는 클라이언트 코드에 숨겨져 클래스의 비공개 API가 됨
- 식별할 수 있는 동작 vs 구현 세부 사항
  - 코드가 시스템의 식별할 수 있는 동작이 되려면
  - 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출
    - 연산: 계산을 수행하거나 사이드 이펙트를 초래하거나
  - 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출
    - 상태: 시스템의 현재 상태
  - 구현 세부 사항은 위 두 가지 중 아무 것도 하지 않음
