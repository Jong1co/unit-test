# Chapter 05 목과 테스트 취약성

## 5.1.1 테스트 대역 유형

- 더미, 스텁, 스파이, 목, 페이크라는 다섯 가지가 존재하나, 실제로는 목과 스텁의 두 가지 유형으로 나눌 수 있음

  - 목: 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 됨
    - 목, 스파이 -> 목에 해당
    - SUT가 **상태를 변경하기 위한 의존성을 호출**하는 것에 해당
    - SMTP 서버로 이메일 발송 -> 목
      - SUT와 관련 의존성 간의 상호 작용을 모방하고 검사함
  - 스텁: 내부로 들어오는 상호 작용을 모방하는 데 도움이 됨
    - 스텁, 더미, 페이크 -> 스텁에 해당
    - SUT가 **입력 데이터를 얻기 위한 의존성을 호출**하는 것에 해당
    - DB에서 데이터 검색 -> 스텁
      - 스텁은 모방만 함

- 스파이: 수동으로 작성함
- 목: 목 프레임워크의 도움을 받아 생성됨
- 더미: 단순하고 하드코딩된 값 (ex. null, 가짜 문자열)
- 스텁: 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성
- 페이크: 대다수의 목적에 부합하는 스텁과 같음
  - 스텁과 페이크의 차이점은 **생성**에 있음
  - 보통 아직 존재하지 않는 의존성을 대체하고자 구현함

## 스텁으로 상호 작용을 검증하지 말라

```c#

[Fact]
public void Creating_a_report()
{
  var stub = new Mock<IDatabase>();
  stub.Setup(x => x.GetNumberOfUsers())
    .Returns(10);
  var sut = new Controller(stub.Object);

  Report report = sut.CreateReport();

  Assert.Equal(10, report.NumberOfUsers)

  // 과잉 명세
  stub.Vertify(
    x => x.GetNumberOfUsers(),
    Times.once
  );
}
```

SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아닌, 최종 결과를 산출하기 위한 수단일 뿐이므로 상호 작용을 검증하는 것은 안티패턴이다.

Mock에서 이메일을 전송하는 행위는 외부로 나가는 상호 작용이고 목적은 사이드 이펙트를 일으키는 것이다.

하지만 stub에서 NumberOfUsers 내부에 존재하는 메서드인 GetNumberOfUsers가 호출되는지 확인하는 것은 내부 구현 세부 사항을 검증하는 것이고,<br/>
이는 과잉 명세로 테스트 취약성으로 이어질 수 있다.

## 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?

명령 조회 분리(CQS)원칙과 관련이 있음

- 명령을 대체하는 것은 목, 조회를 대체하는 것은 스텁

CQS

- 모든 메서드는 명령이거나 조회여야 하며, 이 둘을 혼용해서는 안 된다.
- 명령: 사이드 이펙트를 일으키고 어떤 값도 반환하지 않음
- 조회: 사이드 이펙트가 없고 값을 반환함
  - 질문을 할 때, 답이 달라져선 안 됨(멱등성을 보장해야 함)
- 하지만 특수한 경우(pop의 경우) 반환할 수 있지만, 되도록이면 CQS 원칙을 따르는 것이 좋음

## 식별할 수 있는 동작과 구현 세부 사항

거짓 양성(리팩터링 내성에 실패하는) 주요 이유는 코드의 구현 세부 사항과 결합돼 있기 때문임

- 이를 해결하기 위해서는 강결합을 피해야 하고, 이 방법은 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부 사항과 테스트를 떨어뜨려야 함
- 즉, 테스트가 어떻게가 아닌 무엇에 중점을 두어야 함

## 식별할 수 있는 동작은 공개 API와 다르다.

모든 제품 코드는 2차원으로 분류할 수 있음

- 공개 API vs 비공개 API
  - 클래스의 어떤 멤버라도 private 키워드로 표시할 수 있으며, 해당 멤버는 클라이언트 코드에 숨겨져 클래스의 비공개 API가 됨
- 식별할 수 있는 동작 vs 구현 세부 사항
  - 코드가 시스템의 식별할 수 있는 동작이 되려면
  - 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출
    - 연산: 계산을 수행하거나 사이드 이펙트를 초래하거나
  - 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출
    - 상태: 시스템의 현재 상태
  - 구현 세부 사항은 위 두 가지 중 아무 것도 하지 않음

코드가 실별할 수 있는 동작인지 여부는 클라이언트가 누구인지, 그리고 해당 클라이언트의 목표가 무엇인지에 달려 있음

- 클라이언트는 코드가 있는 위치에 따라 다른 것을 의미하는데, 동일한 코드 베이스, 외부 애플리케이션, 사용자 인터페이스 등을 의미함

## 구현 세부 사항 유출: 연산의 예

```c#
public class User
{
  public string Name { get; set; }

  public string NormalizeName(string name)
  {
    string result = (name ?? "").Trim();

    if(result.length > 50)
      return result.Substring(0, 50);

      return result;
  }
}

public class UserController
{
  public void RenameUser(int userId, string newName)
  {
    User user = GetUserFromDatabase(userId);

    string normalizedName = user.NormalizeName(newName);
    user.Name = normalizedName;

    SaveUserToDatabase(user);
  }
}
```

위 코드가 올바른 코드가 되려면 해당 멤버가 식별할 수 있는 동작이 되게 해야 한다.

- 클라이언트가 목표를 달성하는 데 도움이 되는 작업 또는 상태를 노출해야 한다.

즉, NormalizeName을 별도로 호출하는 것이 아닌, 세터에 의해 Normalize가 호출되어야 한다.<br/>
(NormalizeName은 구현 세부 사항이기 때문에 비공개 API 뒤에 숨겨져 있어야 한다. => 캡슐화)

구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 방법은 다음과 같다.

- 단일한 목표를 달성하고자 클래스에서 호출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있기에 경계하라

### 캡슐화

캡슐화를 하지 않으면 클라이언트는 불변성을 우회해 이름을 먼저 정규화 하지 않고 저장할 수 있음

- 이는 코드 복잡도에 대해 대처할 수 있고,
- 올바른 캡슐화를 유지하여 잘못할 수 있는 옵션조차 제공하지 않도록 하는 것

## 구현 세부 사항 유출: 상태의 예

## 목과 테스트 취약성 간의 관계

### 육각형 아키텍처

도메인과 어플리케이션 서비스 두 계층으로 구성됨 (근데 왜 육각형일까?)

- 도메인 계층: 비즈니스 로직이 포함됨
- 애플리케이션 계층: 외부 환경과의 통신을 조정함
  - Rest API: api 요청 -> 애플리케이션 서비스 계층(도메인 클래스와 프로세스 외부 의존성 간 작업 조정)

육각형 아키텍처의 목적

- 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
  - 애플리케이션 서비스에는 어떤 비즈니스 로직도 있으면 안 됨
  - 도메인 계층을 애플리케이션의 도메인 지식(사용 방법) 모음으로, 애플리케이션 서비스 계층을 일련의 비즈니스 유스케이스(사용대상)으로 볼 수 있음
  - 그렇다면 애플리케이션 서비스 계층은 도메인 계층의 클라이언트인 셈이네?
- 애플리케이션 내부 통신
  - 애플리케이션 -> 도메인으로의 단방향 의존성 흐름을 규정함
  - 이는 애플리케이션이 도메인을 아는 것을 의미하지만 도메인은 애플리케이션을 모름 (완전한 격리가 되어야 함)
- 애플리케이션 간의 통신
  - 외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결됨

애플리케이션의 각 계층은 식별할 수 있는 동작을 나타내며 해당 구현 세부 사항을 포함하고 있음

- 도메인 계층의 식별할 수 있는 동작은 연산과 상태이고, 연산과 상태는 애플리케이션 서비스 계층이 적어도 하나의 목표를 달성하는 데 도움이 된다. (프랙탈 구조 ?)
- 애플리케이션 서비스를 다루는 테스트는 해당 서비스가 외부 클라이언트에게 큰 목표를 어떻게 이루는지 확인함
- 도메인 서비스 테스트는 큰 목표의 하위 목표를 검증함
- 그렇기 때문에 어떤 테스트든 비즈니스 요구 사항으로 거슬러 올라갈 수 있어야 함
- 즉, 각 테스트는 도메인 전문가에게 의미 있는 이야기를 전달해야 하며, 그렇지 않으면 테스트가 구현 세부 사항과 결합돼 있으므로 불안정하다는 강한 암시임
  - 목표가 아닌 것을 검증하는 테스트가 좋지 않은 이유
- 코드 조각이 식별할 수 있는 동작이 되려면 클라이언트가 목표를 달성하도록 도울 필요가 있음
  - 도메인 클래스의 경우 클라이언트는 애플리케이션, 애플리케이션의 경우 외부 클라이언트에 해당이 됨
  - 유틸리티나 인프라 코드에는 적용되지 않는데, 이유는 너무 낮은 수준이고 세밀해서 구체적인 비즈니스 유스케이스로 추적할 수 없기 때문
    - 내 생각: 목적이 특정할 수 없는 다수일 경우에는 테스트 코드를 작성하는 것이 옳지 않다는 뜻일까?

### 시스템 내부 통신과 시스템 간 통신

- 시스템 내부 통신: 클래스 간의 통신(구현 세부 사항)
  - 연산을 수행하기 위한 도메인 클래스 간의 협력은 구현 세부 사항에 해당됨
  - 클라이언트의 목표와 직접적인 관계가 없기 때문
- 시스탬 간의 통신: 다른 애플리케이션과의 통신(식별할 수 있는 동작)
  - 전체적으로 해당 시스템의 식별할 수 있는 동작을 나타냄
- 목을 사용하면 시스템 간의 통신 패턴을 확인할 때 좋음
- 반대로 시스템 내 클래스 간의 통신을 검증하는 데 사용하면 테스트가 구현 세부 사항과 결합되며, 그에 따라 리팩터링 내성 지표가 미흡해짐
