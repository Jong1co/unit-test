# Chapter 02 단위 테스트란 무엇인가

## 2.1 단위 테스트의 정의

단위 테스트는 가장 중요한 세 가지 속성이 있음

- 작은 코드 조각을 검증
- 빠르게 수행
- 격리된 방식으로 처리하는 자동화된 테스트

세번째 **격리된 방식으로 처리하는 자동화된 테스트** 를 두고 격리가 정확히 무엇인지에 대한 의견 차이로 `고전파` 와 `런던파` 의 분파가 갈리게 됨

### 2.1.1 격리 문제에 대한 런던파의 접근

런던파는 코드 조각을 격리된 방식으로 검증함

- 테스트 대상 시스템을 협력자에게서 격리하는 것
- 모든 의존성을 테스트 대역(목)으로 대체해야 함

**런던파의 특징**

- 테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있음
- 객체 그래프를 분할할 수 있음
  - 직접적인 의존성을 갖고 있으며, 그래프가 상당히 복잡해질 수 있는데 런던파는 모든 의존성을 테스트 대역으로 대체하기에 편하게 테스트 코드를 작성할 수 있음
- 테스트 단위에 대한 고민이 줄 수 있음(ex. 클래스가 있으면 클래스에 대한 단위 테스트 클래스를 생성하라!)

```c#
// 고전파

public void Purchase_succeeds_when_enough_inventory()
{
  //arrange
  var store = new Store(); // -> 협력자
  store.AddInventory(Product.Shampoo, 10);
  var customer = new Customer(); // -> SUT(테스트 대상 시스템)

  //act -> 검증하고자 하는 동작을 수행
  bool success = customer.Purchase(store, Product.Shampoo, 5);

  //assert
  Assert.True(success);
  Assert.Equal(5, store.GetInventory(Product.Shampoo))
}

```

- 테스트 대상 메서드를 컴파일 하려면 Store 인스턴스가 필요하기 때문에 Store = 협력자
- 위 코드는 고전적인 방식의 자연스러운 결과로, Customer만이 아닌 Store도 함께 검증함
- 두 클래스는 격리되어 있지 않기 때문에 Store에 오류가 발생하면 단위 테스트에 실패할 수 있음

```c#

//런던파
public void Purchase_succeeds_when_enough_inventory()
{
  //arrange
  var storeMock = new Mock<IStore>(); // -> 협력자
  storeMock
    .Setup(x => x.HasEnoughInventory(Product.Shampoo, 10))
    .Returns(true);
  var customer = new Customer(); // -> SUT(테스트 대상 시스템)

  //act -> 검증하고자 하는 동작을 수행
  bool success = customer.Purchase(storeMock.Object, Product.Shampoo, 5);

  //assert
  Assert.True(success);
  storeMock.Vertify(
    x => x.RemoveInventory(Product.Shampoo, 5),
    Times.Once);
}
```

- Store의 실제 인스턴스를 생성하지 않고, Mock으로 대체. 즉, Store를 사용하지 않음
- 이전에는 Store의 상태를 검증했다면, 지금은 Customer와 Store의 상호작용을 검증함. 즉, RemoveInventory가 한 번 동작하는지를 검증함.
  - 결과와 상호작용을 검증하는구나.

### 2.1.2 격리 문제에 대한 고전파의 접근

- 런던파와 다른 점은 무엇이 작은 코드 조각 단위에 해당하는가
- 고전파의 방식은 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다.
- 공유 의존성이 없는 한 여러 클래스를 묶어서 테스트할 수 있음
- 하지만 단위 테스트는 서로 격리하여 실행해야 한다.
  - 그럼 런던파의 테스트는 격리하여 실행하지 않아도 되는 것인가?
  - 왜 ? -> 외부 의존성을 항상 모킹하는 방식으로 하기에 격리할 필요가 없음
- 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 테스트 대역을 사용함
  - 파일 시스템과 데이터베이스가 이에 해당됨
  - 서로간의 간섭으로 인해 오류가 발생할 수 있기 때문
  - 또한 실행 속도를 높이는 데 필요함 (단위 테스트의 속성 중 빨리 실행해야 하는 필요성이 있기에)
    - 공유 의존성을 포함하는 테스트는 통합 테스트에 포함됨

**의존성**

- 공유 의존성
  - 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
  - ex) 정적 가변 필드
  - TODO: 정적 가변 필드가 무엇인가? 전역 상태와 같은 것인가?
- 휘발성 의존성
  - 비결정적 동작을 포함 (난수 생성기와 현재 날짜를 반환하는 클래스 등)
- 비공개 의존성
  - 공유하지 않는 의존성
- 프로세스 외부 의존성
  - 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
  - db는 프로세스 외부이면서 공유 의존성임
  - 하지만 각 테스트 전에 컨테이너로 실행하면 동일한 인스턴스가 아니기에 공유하지 않는 의존성임

## 2.2 어려움..

## 2.3 고전파와 런던파의 비교

- 단위 테스트 고전파를 선호함 (필자)
- 프로젝트의 지속 가능한 성장을 달성하는 데에 더 적합함 (취약성 때문)
- 런던파
  - 입자성이 좋음
  - 클래스가 커져도 테스트하기 쉬움
  - 어떤 기능이 실패했는지 확실하게 알 수 있음

그런데 좋은 코드 입자성은 오히려 도움이 되지 않는다. 테스트가 단일 동작 단위를 검증하는 한 좋은 테스트이다.

이 것은 응집도와 관련이 있는데 아래 예시를 보면 확실히 이해할 수 있다.

> 응집도가 좋은 예시
> 우리집 강아지를 부르면, 바로 나에게 온다.
>
> 좋지 않은 예시
> 우리집 강아지를 부르면 먼저 왼쪽 앞다리를 움직이고, 이어서 오른쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들기 시작한다.

두 예시를 비교했을 때, 강아지의 목적을 알 수 있는 것은 무엇인가?
<br/>
무조건 첫번째 예시이다. 우리가 알고싶은 것은 강아지를 부르면 나에게 오는 것이지, 어떤 발부터 움직이는지를 알고싶은 것이 아니기 때문이다.

테스트는 해결하는 데 도움이 되는 문제에 대한 이야기를 들려줘야 하며, 프로그래머가 아닌 일반 사람들에게 응집도가 높고 의미 있어야 한다.

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

- 협력자 대신 테스트 대역을 사용하면 테스트에서 준비해야 할 작업량을 크게 줄일 수 있음
- 거대한 클래스는 테스트하기 어려우나, 이는 코드 설계 문제의 결과임
- 테스트 대역을 사용하는 것은 문제를 감추기만 할 뿐, 원인을 해결하지 못함

### 2.3.3 버그 위치 정확히 찾아내기

- 고전파는 하나의 버그가 전체 시스템 테스트의 실패를 야기할 수 있음
- 하지만 테스트를 정기적으로 실행하면 버그 원인을 알아내기 어렵지 않음

### 2.3.4 고전파와 런던파 사이의 차이점

- 런던파 : 하향식 TDD
  - 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작
  - 목을 통해 협력자를 지정함
  - 모든 클래스 구현할 때까지 클래스 그래프를 다져나감
  - 목은 한 번에 한 클래스에 집중할 수 있기에 위 설계 프로세스가 가능함
  - **테스트가 구현에 더 자주 결합됨**
- 고전파 : 상향식 TDD
  - 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다.

## 2.4 두 분파의 통합 테스트

런던파는 협력자 객체를 사용하는 모든 테스트를 통합테스트로 간주함.

고전파의 통합 테스트란

- 단일 동작 단위를 검증하고
- 빠르게 수행하고
- 다른 테스트와 별도로 처리한다.

위 세 조건 중 하나를 충족하지 않는 것들의 집합임

이유:

- 공유 의존성에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없음
- 외부 의존성에 접근하면 테스트가 느려짐
- 둘 이상의 동작 단위를 검증할 때의 테스트는 통합테스트임

### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트

일반적으로 엔드 투 엔드 테스트가 의존성을 더 많이 포함한다.<br/>

- 통합테스트는 프로세스 외부 의존성을 한두 개만 갖고 작동한다.
- 반면 엔드투엔드는 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다. (UI테스트, GUI테스트, 기능 테스트와 같은 용어임)
- 그렇기에 유지보수 측면에서 가장 비용이 많이 든다.
