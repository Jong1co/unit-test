# chapter 06 다ㄴ위 테스트 스타일

## 6.1 단위 테스트의 세 가지 스타일

- 출력 기반 테스트
- 상태 기반 테스트
- 통신 기반 테스트

### 6.1 출력 기반 스타일 정의

SUT에 입력을 넣고 생성되는 출력을 점검하는 방식 (반환 값만을 검증)

- 출력 기반 단위 테스트 스타일은 함수형이라고도 함
- 사이드 이펙트 없는 코드 선호를 강조하는 프로그래밍 방신인 함수형 프로그래밍에 뿌리를 두고 있음

### 6.2 상태 기반 스타일 정의

작업이 완료된 후 시스템 상태를 확인하는 것(최종 상태를 검증함)

- 상태: SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미함

### 6.3 통신 기반 스타일 정의

목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증함 (SUT가 협력자를 올바르게 호출하는지 검증)

## 6.2 단위 테스트 스타일 비교

세 가지 단위 테스트는 앞서 나온 좋은 단위 테스트의 4대 요소를 벗어나지 않음

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기

회귀 방지의 특성은 다음과 같음

- 테스트 중에 실행되는 코드의 양
- 코드 복잡도
- 도메인 유의성

- 어떤 스타일도 첫번째 실행되는 코드의 양 부분에서는 도움이 되지 않음(원하는 대로 테스트를 작성할 수 있기 때문)
- 코드 복잡도와 도메인 유의성 역시 마찬가지
- 통신 기반 스타일에는 예외가 하나 있음
  - (목을) 남용하면 작은 코드 조각을 검증하고 다른 것을 모두 목을 사용하는 등 피상적인 테스트가 될 수 있음
  - 하지만 이는 기술을 남용하는 극단적인 사례임

**즉, 회귀 방지에서는 어떤 스타일도 도움이 되지 않음**

피드백 속도 또한 상관관계가 거의 없음

### 6.2.2 리팩터링 내성 지표로 스타일 비교하기

리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성 수에 대한 척도임

- 출력 기반 테스트: 거짓 양성 방지가 가장 우수함
- 상태 기반 테스트: 거짓 양성이 되기 쉬움
  - 이러한 테스트는 SUT 외에도 클래스 상태와 함께 작동함
  - 확률적으로 테스트와 제품 코드 간의 결합도가 클수록 유출되는 구현 세부 사항에 테스트가 얽매일 가능성이 커짐
  - 상태 기반 테스트는 큰 API 노출 영역에 의존하므로, 구현 세부 사항과 결합할 가능성도 더 높음
- 통신 기반 테스트: 허위 경보에 가장 취약함
  - 항상 스텁과 상호 작용하는 경우 이러한 상호 작용을 확인해서는 안 됨
  - **애플리케이션 경계를 넘는 상호 작용**을 확인하고 해당 상호 작용의 **사이드 이펙트가 외부 환경에 보이는 경우**에만 목이 좋음

### 6.2.3 유지 보수성 지표로 스타일 비교하기

유지 보수성 지표는 단위 테스트 스타일과 밀접한 관련이 있음

유지보수성은 다음 두 가지 특성으로 정의함

- 테스트를 이해하기 얼마나 어려운가? (테스트 크기에 대한 함수)
- 테스트를 실행하기 얼마나 어려운가? (테스트에 직접적으로 관련 있는 프로세스 외부 의존성 개수에 대한 함수)

- 출력 기반 테스트의 유지 보수성
  - 가장 유지 보수하기 용이함
  - 해당 코드는 전역 상태나 내부 상태를 변경할 리 없음(프로세스 외부 의존성을 다루지 않음)
- 상태 기반 테스트의 유지 보수성
  - 출력 기반 테스트보다 유지보수가 쉽지 않음
  - 출력 검증보다 더 많은 공간을 차지하기 때문

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
  var sut = new Article();
  var text = "comment text";
  var author = "John Doe";
  var now = new DateTime(2019, 4, 1);

  sut.AddComment(text, author, now);

// 글의 상태를 검증
  Assert.Equal(1, sut.Comments.Count);
  Assert.Equal(text, sut.Comments[0].Text);
  Assert.Equal(author, sut.Comments[0].Author);
  Assert.Equal(now, sut.Comments[0].DateCreated);
}
```

위 테스트는 단순하고 댓글이 하나 있지만, 검증부는 네 줄에 걸쳐 있다.

- 헬퍼 메서드를 사용하여 해결할 수 있지만, 이러한 메서드를 작성하고 유지하는 데 상당한 노력이 필요함
- 또는 검증 대상 클래스의 동등 멤버를 정의할 수 있음 (테스트만을 위한 코드가 제품 코드에 들어가는 것이 아닐까?)
  - 필자 또한 본질적으로 클래스가 값에 해당하고 값 객체로 변환할 수 있을 때만 효과적이라고 함
  - 그렇지 않으면 코드 오염으로 이어짐
  - 근데 이러한 상태는 제품 코드에서도 유용하게 사용될 거 같음

```c#
[Fact]
public void Adding_a_comment_to_an_article()
{
  var sut = new Article();
  var text = "comment text";
  var author = "John Doe";
  var now = new DateTime(2019, 4, 1);

  sut.AddComment(text, author, now);

  // 헬퍼 메서드
  sut.ShouldContainNumberOfComments(1)
    .WithComment(text, author, now);
}
```

위와 같은 기술을 사용하더라도 출력 기반 테스트보다 공간을 더 많이 차지하므로 유지 보수성이 떨어짐

- 통신 기반 테스트의 유지 보수성

통신 기반 테스트는 sut와 상호 작용 검증을 설정해야 하며, 이는 공간을 더 많이 차지하기 때문에 위 두 개의 스타일보다 유지 보수하기가 어려워짐

### 6.2.4 스타일 비교하기: 결론

|                                  | 출력 기반 | 상태 기반 | 통신 기반 |
| -------------------------------- | --------- | --------- | --------- |
| 리팩터링 내성을 지키기 위한 노력 | 낮음      | 중간      | 중간      |
| 유지비                           | 낮음      | 중간      | 높음      |

- 상태와 통신 기반 테스트는 두 지표 모두 좋지 않음
- 그러므로 출력 기반 테스트를 선호해야 함
- 하지만 대부분 객체지향 프로그래밍 언어에는 해당하지 않음(함수형으로 작성된 코드에만 적용되기 때문)
- 그렇지만 테스트를 출력 기반 스타일로 변경하는 기법은 있음 (코드를 순수 함수로 만들면 됨)

## 6.3 함수형 아키텍처 이해

### 6.3.1 함수형 프로그래밍

함수형 프로그래밍이란 수학적 함수를 사용한 프로그래밍임

- 수학적 함수는 숨은 입출력이 없는 함수로 첫 번째 집합의 각 요소에 대해 두 번째 집합에서 정확히 하나의 요소를 찾는 두 집합 사이의 관계
- 입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지보수하기 쉬우므로 테스트하기가 매우 쉬움
- 반면에 숨은 입출력은 코드를 테스트하기 힘들게 한다
  - 숨은 입출력의 종류
  - 사이드 이펙트: 메서드 시그니처에 표시되지 않은 출력
  - 예외: 메서드가 예외를 던지면, 프로그램 흐름에 메서드 시그니처에 설정된 계약을 우회하는 경로를 만듬
  - 내외부 상태에 대한 참조: DateTime.now와 같이 정적 속성을 사용해 현재 날짜와 시간을 가져오는 메서드가 있을 수 있음
- 수학적 함수인지 판별하는 가장 좋은 방법은 메서드에 대한 호출을 반환 값으로 대체할 수 있는 것 (참조 투명성)

### 6.3.2 함수형 아키텍처란?

어떠한 사이드 이펙트도 일으키지 않는 애플리케이션을 만들 수는 없음
