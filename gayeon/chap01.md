단위 테스트의 목표
=============

단위 테스트의 목표는 테스트에 드는 노력을 가능한 한 줄이고 얻는 이득을 최대화하는 것임

## 1. 단위테스트의 상태

단위 테스트를 적용한 기업을 보면 제품코드와 테스트코드의 비율은 1:1 ~ 1:3정도 된다.
그러나 이제는 단순 작성이 아닌 단위 테스트를 잘! 작성하는 것이 중요하다.

#### 어떤 것이 단위 테스트를 좋게 만들까?

이상적인 단위 테스트는 상황에 따라 다르지만 결국 노력 대비 최대의 이익을 끌어내는 방식이 베스트다.
이 책은 기업용 어플리케이션에 적용하면 좋을 상황들을 알려준다.(비단 그것뿐만은 아니겠지만)

PS) 기업용 애플리케이션?

- 높은 비즈니스 복잡도
- 긴 프로젝트 수명
- 중간 크기의 데이터
- 낮은 or 중간 수준 정도의 성능 요구


## 2. 단위테스트의 목표

단위 테스트를 하기 위해 도움이 되는 묙표가 뭘까? 더 나은 설계? 이건 사이드 이펙트 일뿐 주목표는 아니다!

단위 테스트는 저품질 코드를 가려낸다. 코드를 단위 테스트 하기 어렵다? 이건 개선이 필요하다는 의미이다.
결합이 강한 코드에서 저품질이 나타난다. 그렇지만 코드 조각을 전부 단위 테스트할 수 있다는 것도 좋은 지표는 아니다. 낮은 결합도 또한 안좋은 결과를 도출할때가 있다.

PS) 결합이 강한 코드? 제품 코드가 서로 분리되지 않아 따로 테스트하기 어려운 코드를 말함

결합도 = 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계
응집도 = 응집도는 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미

### 그래서 목표가 뭔데?

프로젝트의 지속 가능한 성장을 추구하는 것이다. 테스트가 없는 프로젝트의 작업소요시간은 초반에는 빠를 수 있으나 진척이 될수록 더 많은 시간을 잡아먹는다.

개발 속도가 빠르게 감소하는 현상을 **소프트웨어 엔트로피** 라고도 한다.
지속적인 정리와 리팩토링을 하지 않으면 시스템이 복잡해지고 무질서해지는 건 당연한 얘기다. (그리고 이걸 하더라도 다른 코드베이스들이 제대로 동작하는지 신뢰하기 어려우니 악순환이 반복된다.)

그에 반해 테스트는 하나를 바꾸더라도 기존 기능이 잘 작동하는지 확인할 수 있으니 도움이 된다.

#### 좋은 테스트와 좋지 않은 테스트를 가르는 요인?

이제 단위 테스트가 좋은건 알겠지만, 단순히 작성하는 것만으로는 안하는것과 거시적으로는 큰 차이가 없다.
모든 테스트를 작성할 필요는 없으니 핵심적인 부분만이라도 작성하는게 도움이 된다.

- 기반 코드를 리팩토링할때 테스트도 리팩토링할것
- 각 코드 변경시 테스트를 실행
- 테스트가 잘못됐다고 알려주면 처리할것
- 기반 코드를 이해하려면 테스트를 읽는데 시간을 투자할것

사람들은 종종 제품코드와 테스트코드를 분리해서 생각한다.
하지만 테스트는 특정 문제를 해결하기 위해 존재하니까 애플리케이션의 정확성을 보장하는 코드로 봐야한다.그러니 단위테스트도 버그에 취약하고 유지보수가 필요한것이다.

## 3. 좋지 않은 테스트 스위트의 결과

널리 사용되는 두가지 커버리지 지표에 대해 얘기해보자.
커버리지 지표 = 테스트 스위트가 소스 코드를 얼마나 실행하는지 백분율로 나타냄
일반적으로 커버리지 숫자가 높을수록 좋다.

그렇지만 과유불급, 너무 적거나 너무 많다고해서 양질의 테스트 스위트라고는 볼수 없다.

PS) 테스트 스위트 = 테스트 실행 목적에 따라 그룹화된 테스트 케이스의 집합

#### 코드 커버리지 지표

가장 많이 사용되는 커버리지 지표

- 코드 커버리지 = 테스트 커버리지 = 실행코드라인수 / 전체 라인수


**서비스 코드**

이런식으로 매개변수 문자열이 긴지를 판별하는 코드가 있다고 보자.
테스트는 문자열 = "abc"등을 사용해 메서드를 점검하고 이 문자열이 긴지아닌지 판별하도록 확인한다.

```
public IsStringLong(String ~){
if( 문자열 > 5){ // 테스트가 다루는 영역
    return true; // 테스트가 다루지 않는 영역
}
return false; // 테스트가 다루는 영역

}
```

**테스트 코드**

여기서 코드 커버리지를 계산한다. 메서드 라인수는 5, 테스트가 실행하는 라인수는 4다.
그렇다면 커버리지는 4/5 = 80% 이다.

```
public ~ {
bool result = IsStringLong("abc");
Assert.Equal(false,result);
}
```

이걸 리팩터링한다면

```
public IsStringLong(String 문자열){
    return 문자열>5;
}

public test(){
    bool result = IsStringLong("abc");
    Assert.Equal(false,result);
}
```

코드 커버리지가 100%로 증가했다. 하지만 리팩터링으로 테스트 스위트는 개선되지 않았다.
단지 메서드내 코드를 바꿨을뿐이고 검증하는 결과 개수는 여전히 같다.

결론은 커버리지 숫자에 집착하는건 의미가 없다는거다.

#### 분기 커버리지

분기 커버리지는 위의 단점을 극복하는데 도움이 된다. 원시코드 라인수를 사용하는 대신 if문과 같은 제어 구조에 중점을 둔다.

- 분기 커버리지 = (통과 분기) / 전체 분기 수

```

public IsStringLong(String 문자열){
    return 문자열>5;
}

public test(){
    bool result = IsStringLong("abc");
    Assert.Equal(false,result);
}

```

IsStringLong의 분기는 두개이다.(5보다 큰경우와 아닌경우)
이때 테스트는 하나의 분기에만 적용된것이므로 분기 커버리지 지표는 50%라고 볼 수 있다.
이는 테스트 코드를 어떻게 작성해도 변하지 않는다는 점에서 코드 커버리지보다 낫다.

그러나 여전히 문제가 있다.

- 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없고
- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

첫번째는 무슨얘기냐면 결과가 여러개 있을수있기때문에 커버리지 지표에 타당성을 부여하려면 모든 측정 지표를 검증해야한단 소리다.

```
bool result = input.Length > 5;
WasLastStringLong = result; -> 첫번째 결과(WasLastStringLong가 외부에서 선언된 변수라고 가정)
return result -> 두번째 결과
```

이 경우 테스트코드는 두번째 결과만 검증하고 어디선가 쓰일지도 모르는 WasLastStringLong는 검증하지 않는다. 이 경우에도 코드 커버리지는 첫번째 결과값에 대해 유의미한 판단을 내리고 있지 않다.(일부만 보장하는 셈)

또는 

```
public test(){
    bool result = IsStringLong("abc"); // true
    bool result = IsStringLong("abcedsfdss"); // false
}

```

이런식으로 검증이 없는 테스트는 언제나 100%를 나타내기때문에 여전히 쓸모가 없다.

## 4. 테스트 스위트 커버리지 지표

## 5. 성공적인 테스트 스위트 속성

이 책을 통해 배우는 것

- 