단위 테스트의 목표
=============

단위 테스트의 목표는 테스트에 드는 노력을 가능한 한 줄이고 얻는 이득을 최대화하는 것임

## 1. 단위테스트의 상태

단위 테스트를 적용한 기업을 보면 제품코드와 테스트코드의 비율은 1:1 ~ 1:3정도 된다.
그러나 이제는 단순 작성이 아닌 단위 테스트를 잘! 작성하는 것이 중요하다.

#### 어떤 것이 단위 테스트를 좋게 만들까?

이상적인 단위 테스트는 상황에 따라 다르지만 결국 노력 대비 최대의 이익을 끌어내는 방식이 베스트다.
이 책은 기업용 어플리케이션에 적용하면 좋을 상황들을 알려준다.(비단 그것뿐만은 아니겠지만)

PS) 기업용 애플리케이션?

- 높은 비즈니스 복잡도
- 긴 프로젝트 수명
- 중간 크기의 데이터
- 낮은 or 중간 수준 정도의 성능 요구


## 2. 단위테스트의 목표

단위 테스트를 하기 위해 도움이 되는 묙표가 뭘까? 더 나은 설계? 이건 사이드 이펙트 일뿐 주목표는 아니다!

단위 테스트는 저품질 코드를 가려낸다. 코드를 단위 테스트 하기 어렵다? 이건 개선이 필요하다는 의미이다.
결합이 강한 코드에서 저품질이 나타난다. 그렇지만 코드 조각을 전부 단위 테스트할 수 있다는 것도 좋은 지표는 아니다. 낮은 결합도 또한 안좋은 결과를 도출할때가 있다.

PS) 결합이 강한 코드? 제품 코드가 서로 분리되지 않아 따로 테스트하기 어려운 코드를 말함

- 결합도 = 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계
- 응집도 = 응집도는 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미

### 그래서 목표가 뭔데?

프로젝트의 지속 가능한 성장을 추구하는 것이다. 테스트가 없는 프로젝트의 작업소요시간은 초반에는 빠를 수 있으나 진척이 될수록 더 많은 시간을 잡아먹는다.

개발 속도가 빠르게 감소하는 현상을 **소프트웨어 엔트로피** 라고도 한다.
지속적인 정리와 리팩토링을 하지 않으면 시스템이 복잡해지고 무질서해지는 건 당연한 얘기다. (그리고 이걸 하더라도 다른 코드베이스들이 제대로 동작하는지 신뢰하기 어려우니 악순환이 반복된다.)

그에 반해 테스트는 하나를 바꾸더라도 기존 기능이 잘 작동하는지 확인할 수 있으니 도움이 된다.

#### 좋은 테스트와 좋지 않은 테스트를 가르는 요인?

이제 단위 테스트가 좋은건 알겠지만, 단순히 작성하는 것만으로는 안하는것과 거시적으로는 큰 차이가 없다.
모든 테스트를 작성할 필요는 없으니 핵심적인 부분만이라도 작성하는게 도움이 된다.

- 기반 코드를 리팩토링할때 테스트도 리팩토링할것
- 각 코드 변경시 테스트를 실행
- 테스트가 잘못됐다고 알려주면 처리할것
- 기반 코드를 이해하려면 테스트를 읽는데 시간을 투자할것

사람들은 종종 제품코드와 테스트코드를 분리해서 생각한다.
하지만 테스트는 특정 문제를 해결하기 위해 존재하니까 애플리케이션의 정확성을 보장하는 코드로 봐야한다.그러니 단위테스트도 버그에 취약하고 유지보수가 필요한것이다.

## 3. 좋지 않은 테스트 스위트의 결과

널리 사용되는 두가지 커버리지 지표에 대해 얘기해보자.
커버리지 지표 = 테스트 스위트가 소스 코드를 얼마나 실행하는지 백분율로 나타냄
일반적으로 커버리지 숫자가 높을수록 좋다.

그렇지만 과유불급, 너무 적거나 너무 많다고해서 양질의 테스트 스위트라고는 볼수 없다.

#### 테스트 스위트 = 테스트 실행 목적에 따라 그룹화된 테스트 케이스의 집합

#### 코드 커버리지 지표

가장 많이 사용되는 커버리지 지표

- 코드 커버리지 = 테스트 커버리지 = 실행코드라인수 / 전체 라인수


**서비스 코드**

이런식으로 매개변수 문자열이 긴지를 판별하는 코드가 있다고 보자.
테스트는 문자열 = "abc"등을 사용해 메서드를 점검하고 이 문자열이 긴지아닌지 판별하도록 확인한다.

```
public IsStringLong(String ~){
if( 문자열 > 5){ // 테스트가 다루는 영역
    return true; // 테스트가 다루지 않는 영역
}
return false; // 테스트가 다루는 영역

}
```

**테스트 코드**

여기서 코드 커버리지를 계산한다. 메서드 라인수는 5, 테스트가 실행하는 라인수는 4다.
그렇다면 커버리지는 4/5 = 80% 이다.

```
public ~ {
bool result = IsStringLong("abc");
Assert.Equal(false,result);
}
```

이걸 리팩터링한다면

```
public IsStringLong(String 문자열){
    return 문자열>5;
}

public test(){
    bool result = IsStringLong("abc");
    Assert.Equal(false,result);
}
```

코드 커버리지가 100%로 증가했다. 하지만 리팩터링으로 테스트 스위트는 개선되지 않았다.
단지 메서드내 코드를 바꿨을뿐이고 검증하는 결과 개수는 여전히 같다.

결론은 커버리지 숫자에 집착하는건 의미가 없다는거다.

#### 분기 커버리지

분기 커버리지는 위의 단점을 극복하는데 도움이 된다. 원시코드 라인수를 사용하는 대신 if문과 같은 제어 구조에 중점을 둔다.

- 분기 커버리지 = (통과 분기) / 전체 분기 수

```

public IsStringLong(String 문자열){
    return 문자열>5;
}

public test(){
    bool result = IsStringLong("abc");
    Assert.Equal(false,result);
}

```

IsStringLong의 분기는 두개이다.(5보다 큰경우와 아닌경우)
이때 테스트는 하나의 분기에만 적용된것이므로 분기 커버리지 지표는 50%라고 볼 수 있다.
이는 테스트 코드를 어떻게 작성해도 변하지 않는다는 점에서 코드 커버리지보다 낫다.

#### 그러나 여전히 문제가 있다.

- 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없고
- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

첫번째는 무슨얘기냐면 결과가 여러개 있을수있기때문에 커버리지 지표에 타당성을 부여하려면 모든 측정 지표를 검증해야한단 소리다.

```
bool result = input.Length > 5;
WasLastStringLong = result; -> 첫번째 결과(WasLastStringLong가 외부에서 선언된 변수라고 가정)
return result -> 두번째 결과
```

이 경우 테스트코드는 두번째 결과만 검증하고 어디선가 쓰일지도 모르는 WasLastStringLong는 검증하지 않는다. 이 경우에도 코드 커버리지는 첫번째 결과값에 대해 유의미한 판단을 내리고 있지 않다.(일부만 보장하는 셈)

또는 

```
public test(){
    bool result = IsStringLong("abc"); // true
    bool result = IsStringLong("abcedsfdss"); // false
}

```

이런식으로 검증이 없는 테스트는 언제나 100%를 나타내기때문에 쓸모가 없다.
또한 결과에 대해 검증한다해도 다른 문제가 존재한다.

두번째론 외부 라이브러리의 코드 경로를 고려할 수 없다.

```
public int Parse(String input){
    return int.Parse(input);
}

public test(){
    int result = Parse("5");
    Assert.Equal(5,result);
}

```

이 경우 Parse메소드는 분기가 없고 외부 라이브러리를 호출하기때문에 test는 분기 커버리지 100%인 상황이다.
그러나 이는 int.Parse의 내부 동작까지 고려한 테스트 설계는 아닌셈이다.

이런식으로 외부 라이브러리의 숨겨진 코드 경로는 커버리지 지표가 얼마나 있는지, 테스트가 얼마나 수행하는지 알 방법이 없다.

int.Parse 내부에서는
- null값
- 빈 문자열
- 정수가 아님
- 너무 긴 문자열  

또한 고려하고 동작하고 있기에 수많은 예외상황에 빠질 수 있다. 하지만 테스트에선 모든 예외 상황을 다루는지 확인할 방법이 없다.

결론은 외부 라이브러리를 고려해야한다! 가 아니라 커버리지 지표로써는 많은걸 판단하지 못한다는 얘기다.

#### 그렇다면 커버리지 숫자를 목표로 테스트를 설계하는건 잘못됐을까?

물론 테스트 커버리지 지표만으로는 뭘 판단하기엔 불충분할수있다. 이는 커버리지 숫자를 목표로 삼지말고 하나의 지표로 고려해야한다.

병에 걸린 환자도 열이 많다해서 열을 내리는 것 그 자체는 병이 낫는 하나의 지표겠지만, 열이 내렸다해서 병이 나았다는걸 의미하진 않으니까 말이다.

커버리지 지표는 좋은 부정 지표이자 나쁜 긍정 지표다.
커버리지 숫자가 낮으면 문제가 있다고 볼 수 있지만, 높다고해서 엄청나게 큰 의미가 있는 것도 아니다.(하방만 보장해준다는것)

## 4. 테스트 스위트 커버리지 지표

성공한 테스트 스위트의 특성
- 개발 주기에 통합돼 있다.
  - 이상적으로는 코드가 변경 = 테스트를 함이다.

- 코드베이스에서 가장 중요한 부분만을 대상으로 함
  - 시스템의 가장 중요한 부분에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 검증하는 것이 좋다.
  - **그래서 어디가 중요하느냐 = 비즈니스 로직이 있는 부분!**
  - 다른 부분은 뭐가 있는데?
    - 인프라 코드
    - 데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성
    - 모든것을 하나로 묶는 코드
- 최소한의 유지비, 최대의 가치
  - 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다
    - 가치 있는 테스트 식별하기
    - 가치 있는 테스트 작성하기
  - 좋은 것을 만들어 내는게 어렵기 때문에 서비스 코드 설계부터 잘해야한다.

## 5. 성공적인 테스트 스위트 속성

이 책을 통해 배우는 것 기초 다기지 + 기술과 실천

- 제품코드와 테스트스위트를 리팩터링하는방법
- 단위테스트의 다양한 스타일 적용
- 통합 테스트로 전체 동작 검증
- 단위테스트로 안티패턴 식별&예방

와~ 기대되네욤ㅎㅎ